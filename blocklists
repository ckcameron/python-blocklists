#!./bin/python
#################################################################################################################
#################################################################################################################
# blocklists 
#
# Copyright 2025, CK Cameron (chase@ckcameron.net), Shared under the Gnu General Public License, version 3.0 ONLY
# Written in Python 3.14, using libraries re, pathlib, socket, time, elevate-updated, argparse and ipaddress
#
# This program will parse a list of files and directories, to scrape each line for ipaddresses, 
#     and domain names. Domain names will be looked up for associated IPs. IPs and domains will 
#     be written to their respective files, and finally optimized by sorting, removing duplicate 
#     entries, and condensing the list of IPs into as few IP ranges as possible. If selected, the
#     script will also create an ipset blocklist and add rules to your iptables firewall
#     (the default rule is drop).
#
# This program is distributed WITHOUT ANY WARRANTY; this includes it being without the implied warrant of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#################################################################################################################

# Import libraries

import http.client
import socket
import ssl
import subprocess
import sys
import tempfile
import multiprocessing as mp
import re
from multiprocessing.pool import Pool
from pathlib import Path
from elevate import elevate
import ipaddress
import socket
import time
import os
import argparse
import traceback
import concurrent.futures
import requests
import dask.multiprocessing

####### Global Functions ##########

      ## Note: these functions were not included in a class because the multiprocessing module cannot pickle the functions of a class
      ## readily. The easiest solution was to do all the multi-processing-related stuff in global functions.
      ## I may revise this with a different concurrency library later.

# Optimize the IP data for each file and re-write the output files with the optimized data.

def optimizeIps( self ):
    print( "\nNow optimizing IP blockfile and removing duplicates...." )

    # Sort IPs.

    self.ips_v4 = sorted( self.ips_v4, key=ipaddress.ip_address )

    # Optimize the list of IPs for ipset by removing duplicates and compressing addressses into as many contiguous ranges as possible.
    # Then delete the contents of the IP block file to write the optimized contents to it.

    uniqueips_v4 = list( set( self.ips_v4 ) )
    print( "\nIP count after removing duplicates:", len( uniqueips_v4 ) )
    time.sleep( 2 )
    ipsoptimized_v4 = list( ipaddress.collapse_addresses( uniqueips_v4 ) )
    time.sleep( 2 )
    print( "\nEntry count after collapsing ip ranges:", len( ipsoptimized_v4 ) )
    self.queued = []
    for iprange in ipsoptimized_v4:
        self.queued.append( iprange )
    self.ipBlocks_v4.seek( 0 )
    self.ipBlocks_v4.truncate( )
    for entry in self.queued:
        self.ipBlocks_v4.write( ( entry + '\n' ) )
    print( self.ipcount_v4, "\nIPs including ", ( self.ipcount_v4 - len( self.ips_v4 ) ), "IPs or ranges added to the blockfile." )

# Optimize the list of domains by eliminating duplicates and sorting them alphabetically before
# deleting the contents of the blockfile and writing the optimized contents to it.

def optimizeDomains( self ):


    print( '\n\nNow optimizing the domain block file by removing duplicate entries and ordering the entries alphabetically.' )
    self.domains = list( set( self.domains ) )
    self.domains = sorted( self.domains )
    self.domainBlocks.seek( 0 )
    self.domainBlocks.truncate( )
    for domain in self.domains:
        self.domainBlocks.write( domain + "\n" )
    print( self.domaincount, "domains added to the block file.\n" )

# Take a line of input, remove any 0.0.0.0 entries, search for another existent IP Address in the line,
# and add it to the IP blockfile and the list of IPs. Stop processing the function by returning
# True if an IP is found, written and appended to the IP list.

def processDomains( file ):


    global ips_v4
    global ips_v6
    global ipcount_v4
    global ipcount_v6
    global total_ipcount
    global ipv6
    global domaincount
    global domains
    try:
        localfile = open( file, 'r' )
    except UnicodeDecodeError:
        print( f"File {file} could not be read. Skipping." )
        pass
        return False
    lines = localfile.readlines( )
    file_ipcount_v4: int = 0
    file_ipcount_v6: int = 0
    file_domaincount: int = 0
    file_domains = []
    file_ips_v4 = []
    file_ips_v6 = []
    for string in lines:
        match_v4 = re.findall( r"\b(?:(?:2(?:[0-4][0-9]|5[0-5])|[0-1]?[0-9]?[0-9])\.){3}(?:(?:2(?:[0-4][0-9]|5[0-5])|[0-1]?[0-9]?[0-9]))(?:\/(?:[12]?[0-9]|3[0-2]))?\b", string )
        match_v6 = re.findall( r"\b^((?:[0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}|(?:[0-9A-Fa-f]{1,4}:){1,7}:|:(?::[0-9A-Fa-f]{1,4}){1,7}|(?:[0-9A-Fa-f]{1,4}:){1,6}:[0-9A-Fa-f]{1,4}|(?:[0-9A-Fa-f]{1,4}:){1,5}(?::[0-9A-Fa-f]{1,4}){1,2}|(?:[0-9A-Fa-f]{1,4}:){1,4}(?::[0-9A-Fa-f]{1,4}){1,3}|(?:[0-9A-Fa-f]{1,4}:){1,3}(?::[0-9A-Fa-f]{1,4}){1,4}|(?:[0-9A-Fa-f]{1,4}:){1,2}(?::[0-9A-Fa-f]{1,4}){1,5}|[0-9A-Fa-f]{1,4}:(?:(?::[0-9A-Fa-f]{1,4}){1,6})|:(?:(?::[0-9A-Fa-f]{1,4}){1,6}))$", string )
        match_v6_cidr = re.findall( r"\b(?:(?:(?:[A-F0-9]{1,4}:){6}|(?=(?:[A-F0-9]{0,4}:){0,6}(?:[0-9]{1,3}\.){3}[0-9]{1,3}(?![:.\w]))(([0-9A-F]{1,4}:){0,5}|:)((:[0-9A-F]{1,4}){1,5}:|:)|::(?:[A-F0-9]{1,4}:){5})(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)|(?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}|(?=(?:[A-F0-9]{0,4}:){0,7}[A-F0-9]{0,4}(?![:.\w]))(([0-9A-F]{1,4}:){1,7}|:)((:[0-9A-F]{1,4}){1,7}|:)|(?:[A-F0-9]{1,4}:){7}:|:(:[A-F0-9]{1,4}){7})(?![:.\w])\/(?:12[0-8]|1[01][0-9]|[1-9]?[0-9])\b", string )
        combinedv6 = match_v6 + match_v6_cidr
        for address in match_v4:
            if address != '0.0.0.0':
                file_ipcount_v4 += 1
                file_ips_v4.append( address )
        if ipv6 == 1:
            for address in combinedv6:
                file_ipcount_v6 += 1
                file_ips_v6.append( address )

        # Now search the line for domain, subdomains, and tld, add the group to the domain blocklist.

        hostmatch = re.findall(r"\b^((?!-)[A-Za-z0-9-]{1,63}(?<!-)\.)+[A-Za-z]{2,63}$\b", string)
        for host in hostmatch:
            file_domains.append(host)
            file_domaincount += 1

    # Report file totals

    total_ipcount += ( file_ipcount_v4 + file_ipcount_v6 )
    print( f"File : {file} processed.\n\n\nThe following {file_domaincount} domains were added to the blocklist:\n {file_domains}\n\nThe following {file_ipcount_v4} IPv4 addresses were added to the blocklist: \n{file_ips_v4}\n\nThe following {file_ipcount_v6} IPv6 addresses were added to the blocklist: \n{file_ips_v6}\n\n...... {total_ipcount} IP addresses added to the blocklist." )

    # Concatenate the file data after extracting the ips/domains and write the extracted data to the output files as a batch

    addresses_str: str = str( f"# {file}\n" )
    for address in file_ips_v4:
        address_with_newline: str = f"{address}\n"
        addresses_str += address_with_newline
    ipBlocks_v4.write( addresses_str )
    addresses_str: str = str( f"# {file}\n" )
    if ipv6 == 1:
        for address in file_ips_v6:
            address_with_newline: str = str( f"{address}\n" )
            addresses_str += address_with_newline
        ipBlocks_v6.write( addresses_str )
    domains_str: str = str( f"# {file}\n" )
    for domain in file_domains:
        domains_str += str( f"{domain}\n" )
    domainBlocks.write( domains_str )

# Attempt to lookup the given domain name in each line and find associated IP address records,
# without failure if no result or an error is returned. Write associated IPs to the IP blocklist
# and blockfile.

def ipLookup( domain ):
    try:
        hostinfo = socket.gethostbyname_ex( domain )
        [ ( print( f"IP address(es): {hostinfo[2]} added to the ip block file." ) ) for address in hostinfo[2] if hostinfo[2] is not None and address not in ips_v4 ]
        for address in hostinfo[2]:
            if hostinfo[2] is not None:
                if address not in ips_v4:
                    ipcount_v4 += 1
                    ips_v4.append( address )
                    print( f"Adding IPv4 address {address} to the blocklist for domain {domain}" )
                    ipBlocks_v4.write( f"{address}\n" )


        if ipv6 == 1:
            hostaddrinfo = socket.getaddrinfo( domain, None,  socket.AF_INET6 )
            for address in hostaddrinfo[0]:
                if hostaddrinfo[0] is not None:
                    if address not in ips_v6:
                        ipcount_v6 += 1
                        ips_v6.append( address )
                        print( f"Adding IPv6 address {address} to the blocklist for domain {domain}" )
                        ipBlocks_v6.write ( f"{address}\n" )

# Print any exception caught in the process

    except Exception as err:
        print( "Caught an exception:" )
        traceback.print_exc( )
        print( "Program continues to run after the traceback." )

# Print to stderr

def eprint(*args, **kwargs):
    print( *args, file=sys.stderr, **kwargs )

# Define a class for user input.

class Input:

    def __init__(self):

        # Parse arguments passed to the script and, if necessary, gather missing data.

        self.parser = argparse.ArgumentParser(
            prog='blocklists.py',
            description='''A python cli for creating blocklists / ipsets and adding the rules to your iptables firewall.''',
            epilog="Copyright 2025 CK Cameron (chase@ckcameron.net), Licensed under GPLv3, all rights reserved.",
            usage='%(prog)s [options]'
            )
        self.parser.add_argument('-f', '--files', default = '',
                                 help = "input blocklist filename(s) or directories, comma-separated" )
        self.parser.add_argument('-6', '--ipv6', default = '0', help = "optional IPv6 processing (Default = No)" )
        self.parser.add_argument('-i', '--interactive', default='1',
                                 help = "interactive mode will ask for values for needed variables and about including operations" )
        self.parser.add_argument('-is', '--ipset', default = '0', help = "create ipset blocklists" )
        self.parser.add_argument('-in4', '--ipset4_name', default = 'blocklists-set',
                                 help = "ipset IPv4 blocklist name or name prefix" )
        self.parser.add_argument('-in6', '--ipset6_name', default='blocklists-set',
                                 help = "ipset IPv6 blocklist name or name prefix" )
        self.parser.add_argument('-il', '--ipset_location', default='/etc/ipset',
                                 help = "ipset config file location (Default: /etc/ipset)" )
        self.parser.add_argument('-it', '--ipset_type', default = 'net:hash', help="ipset type, default=net:hash" )
        self.parser.add_argument('-oi4', '--output_ip_list_v4', default = '',
                                 help = "output IPv4 blocklist filename or directory" )
        self.parser.add_argument('-oi6', '--output_ip_list_v6', default = '',
                                 help = "output IPv6 blocklist filename or directory" )
        self.parser.add_argument('-od', '--output_domain_list', default = '',
                                 help = "output domain blocklist filename or directory" )
        self.parser.add_argument('-ipt', '--iptables_rules', default='0',
                                 help = "add iptables rules to firewall. The default blocks incoming and outgoing traffic across all connections to or from those ips." )
        self.parser.add_argument('-ipto', '--iptables_options', default = '-j DROP',
                                 help = "iptables options to customize the rule, the ipset name(s) taken from the supplied argument. When using this options all flags beyond the ipset name for the rule need to be included. These include things like tables, direction, actions, ports." )
        self.args = self.parser.parse_args( )

        # When in interactive mode, ather essentail inputs and determine if the user would like ipsets created, config files written, etc.

        if self.args.interactive == 1:
            self.args.files = input( "Please enter a comma-separated list of directories or files to be parsed: " )
            self.args.output_domain_list = input( "Please enter the name of the output domain block file: " )
            self.args.output_ip_list_v4 = input( "Please enter the name of the output IPv4 block file: " )
            if self.args.ipv6 == 1:
                self.args.output_ip_list_v6 = input( "Please enter the name of the output IPv6 block file: " )
            self.args.ipset = input( "Do you want to create the ipset file int /etc/ipsets? (Y/N)" )

            # Gain root privileges if we are doing operations that require it.
            if self.args.ipset == 'Y' or 'y':
                self.args.ipset4_name = input(
                    "Please provide a name for the ipset(s) to be created (Default blocklists-ipset_v4-{number}): " )
            self.args.ipset6_name = input(
                "Please provide a name for the ipset(s) to be created (Default blocklists-ipset_v6-{number}): " )
            self.args.ipset_location = input(
                "Please provide a folder where the output ipset files should be placed (Default /etc/ipset.d): " )
            self.args.ipset_type = input("Please provide a type of ipset(s) to be created: " )
            self.args.iptables_rules = input(
                "Shall the script create iptables rules for the ipset(s) created? (Y/N [default]) " )
            self.args.iptables_options = input(
                "Enter iptables options to be appended after the ipset name in the rules, or hit [Enter] for the default incoming and outgoing block: " )
            while os.geteuid() != 0:
                print(
                    "\n[sudo] password for %u required to run this script with currently given options. \n\nPlease enter your sudo password:" )
                elevate()
        if self.args.iptables_options == '':
            self.args.iptables_options = '-j DROP'

        # If minimal arguments are not supplied and the script is not in interactive mode, explain what is missing and exit.

        if self.args.files == '':
            raise ( '\n\nRequired input files or directories not given. Exiting.' )
        if self.args.output_ip_list_v6 == '' and self.args.ipv6 == 1:
            raise ( "Output IPv6 list filename not given. Exiting." )
        else:
            if self.args.ipv6 == 1 or 'Y' or 'y':
                self.output_ip_list_v6 = Path( self.args.output_ip_list_v6 )
            else:
                pass
        if self.args.output_ip_list_v4 == '':
            raise ( "Output IPv4 list filename not given. Exiting." )
        else:
            self.output_ip_list_v4 = Path( self.args.output_ip_list_v4 )
        if self.args.output_domain_list == '':
            raise ( "Output domain list filename not given. Exiting." )
        else:
            self.output_domain_list = Path( self.args.output_domain_list )

        # Parse user input for filenames and directories, adding any files to the list to parse.

        self.userInput = self.args.files.split( "," )
        self.items = []
        for thing in self.userInput:
            for item in ( Path( thing ) ).rglob( '*' ):
                if item.is_file( ) and item not in self.items:
                    self.items.append( item )
                    print( item, " added to the list for processing." )
                    time.sleep( 0.001 )


# Create a class for the processed ip and domain lists

class DomainIpLists:

    def __init__( self, inputobj, outputipobj_v4, outputipobj_v6, outputdomainobj ):
        # Create necessary variables and empty lists

        self.ipcount_v6: int = 0
        self.ips_v6 = []
        self.domaincount: int = 0
        self.ipcount_v4: int = 0
        self.ips_v4 = []
        self.ipset_location = user_input.args.ipset_location
        self.input = inputobj
        self.ipBlocks_v4 = outputipobj_v4
        self.ipBlocks_v6 = outputipobj_v6
        self.domainBlocks = outputdomainobj
        self.domains = []
        self.domain: str = ""
        self.file: str = ""
        self.queued = None
        self.extracted = None


# Class for a subnet's network address and mask to be cached

class Network:

    def __init__( self, subnet ):
        network = ipaddress.ip_network( subnet )
        self.network_ipspace = int( network.network_address )
        self.subnet_mask = int( network.netmask )

# Creates ipset blocklist from optimized ip blockfiles. IPv4 and IPv6 Supported.

class IpsetBlocklist:

    def __init__( self ):
        self.blocklists_file_v4 = user_input.output_ip_list_v4
        self.ipset4_file = str( f"{user_input.args.ipset_location}/{self.args.ipset4_name}" )

        self.blocklist_list = []
        self.ipset_v4 = []
        self.ipset_v6 = []

        self.temporary_ipset_name_v4 = "ipset-blocklist"
        self.permanent_ipset_basename_v4 = user_input.args.ipset4_name
        if ipv6 == 1:
            self.temporary_ipset_name_v6 = "ipset-blocklist6"
            self.permanent_ipset_basename_v6 = user_input.args.ipset6_name
        self.verbose = False

    # Write file headers by ipset restore

    @classmethod
    def writeHeader( cls, temporary_ipset_name_v4, header ):
        temporary_ipset_name_v4.write( bytearray( "{}\n".format( header ), 'utf-8' ) )
        temporary_ipset_name_v4.flush( )

    #Generate headers for ipsets


    @classmethod
    def genHeaderIp( cls, name, range, family="inet", comment=True, maxelem=65535 ):
        format_string = None
        if comment:
            format_string = "create {} bitmap:ip range {} maxelem {} comment"
        else:
            format_string = "create {} bitmap:ip range {} maxelem {}"
        return format_string.format(name, range, family, maxelem )

    # ipset restore the filename

    @classmethod
    def restoreIpsetFile(cls, filename):
        cmd = "ipset -exist -f {} restore".format( filename ).split( " " )

        process = subprocess.Popen( cmd )
        process.wait( )

        if process.returncode != 0:
            print( "Restoring the ipset {} failed with error {}".format(filename, process.returncode ) )
            return False
        return False

    # Generate names and ipsets for the different address families

    @classmethod
    def nameFormat(cls, name):
        ipv4_ending = "_v4"
        ipv6_ending = "_v6"
        return "{}{}".format(name, ipv4_ending), "{}{}".format(name, ipv6_ending)

    # Destroy existing  ipset

    @classmethod
    def ipsetDestroy( cls, set_1 ):
        cmd = "ipset destroy {}".format( set_1 ).split( " " )

        process = subprocess.Popen( cmd )
        process.wait( )
        if process.returncode != 0:
            print( "Deleting the ipset {} returned error {}".format(set_1, process.returncode ) )
            return False
        return True

    # Swap the two given ipsets.

    @classmethod
    def swapIPsets( cls, set_1, set_2 ):
        cmd = "ipset swap {} {}".format(set_1, set_2 ).split( " " )

        process = subprocess.Popen( cmd )
        process.wait( )
        if process.returncode != 0:
            eprint( "Swapping the ipsets {} and {} returned error {}".format(
                set_1, set_2, process.returncode ) )
            return False
        return True

    # Download blocklists - not yet impllemented -coming soon
    #    def get_list( self ):
    #
    #    ctx = ssl.create_default_context( )
    #    ctx.options |= ssl.OP_NO_TLSv1
    #    ctx.options |= ssl.OP_NO_TLSv1_1
    #    ctx.options |= ssl.OP_NO_COMPRESSION

    #    # https connection for download

    #    connection = http.client.HTTPSConnection(
    #        self.blocklists_fqdn,
    #        context=ctx, timeout=5 )
    #    try:
    #        connection.connect( )
    #    except:
    #        eprint( "Connection error." )
    #
    #    try:
    #        connection.request( "GET", self.blocklists_file_v4 )
    #    except socket.error as e:
    #        eprint( "Socket error: {}".format( e ) )
    #        return False
    #    except socket.timeout as timeout:
    #        eprint( "Socket error: Connection timed out." )
    #        return False

    #   response = connection.getresponse( )

    #    if response.status != 200:
    #        eprint( "Server responded with statuscode {}. Aborting".format( response.statuscode ) )
    #        return False

    #    body = response.read( )
    #    if not body:
    #        eprint( "Server didn't send us any data." )
    #        return False

    #    self.blocklist_list = body.decode( ).split( "\n" )
    #   return True

    # Filter ipblocklists for bogon and private addresses and process the ipset files

    def processIpsets( self ):
        ipcount = 0


        # set up IPv4 and IPv6 temporary files

        private_v4 = []
        for net in [
                "0.0.0.0/8", "10.0.0.0/8", "100.64.0.0/10", "172.16.0.0/12",
                "192.168.0.0/16", "169.254.0.0/16", "255.0.0.0/8",
                "224.0.0.0/4"
            ]:
            private_v4.append( Network( net ) )

        private_v6 = []
        for net in [
                "ff00::/8",
                "fe80::/10",
                "fd00::/8"
            ]:
            private_v6.append( Network ( net ) )

        temporary_file_v4 = tempfile.NamedTemporaryFile( )
        temporary_file_v6 = tempfile.NamedTemporaryFile( )

        add_template = "add {} {}\n"

        temporary_ipset_name_v4, temporary_ipset_name_v6 = self.nameFormat(
            self.temporary_ipset_name_v4 )

        permanent_ipset_basename_v4, permanent_ipset_basename_v6 = self.nameFormat(
            self.permanent_ipset_name_v4 )

        self.writeHeader( temporary_file_v4.file, self.genHeaderIp( temporary_ipset_name_v4 ) )

        self.writeHeader( temporary_file_v6.file, self.genHeaderIp( temporary_ipset_name_v6, family="inet6" ) )

        # Write the formatted blockset.

        for address in lists.ips_v4 or lists.ips_v6:

            # Check if it's IPv4.

            if address.find( "." ) != -1:

                # Check for private subnet.

                for inv in invalid_v4:
                    if ( int( ipaddress.ip_address( address ) ) & inv.mask ) == inv.network:
                        continue
                temporary_file_v4.file.write( bytearray(
                    add_template.format(temporary_ipset_name_v4, address ), 'utf-8' ) )
                ipcount += 1

            # else IPv6.

            else:

                # Check for private subnet.

                for inv in invalid_v6:
                    if ( int( ipaddress.ip_address( address ) ) & inv.mask ) == inv.network:
                        continue
                temporary_file_v6.file.write(bytearray(
                    add_template.format(temporary_name_v6, i ), 'utf-8' ) )
                ipcount += 1

        # Flush the data to the tempfiles.

        temporary_file_v4.file.flush( )
        temporary_file_v6.file.flush( )

        # IPv4: place new ips in new set.

        self.restoreIpsetFile( temporary_file_v4.name )

        # Swap the temporary for the permanent set.

        self.swapIpsets( permanent_name_v4, temporary_name_v4 )

        # Wipe the old ipset

        self.ipsetDestroy( temporary_name_v4 )

        # IPv6: place new ips in new set.

        self.restoreIpsetFile( temporary_file_v6.name )

        # Swap the temporary for the permanent set.

        self.swapIpsets( permanent_name_v6, temporary_name_v6 )

        # Wipe the old set.

        self.ipsetDestroy( temporary_name_v6 )

        # Print results.

        print( "{} IPs added to the ipsets".format( ipcount ) )

###### Main portion of the script using the above classes ######

# Instantiate user input and parse arguments

user_input = Input()

# Open the blockfile(s)

domainBlocks =  open( user_input.output_domain_list, 'a+' )
ipBlocks_v4 = open( user_input.output_ip_list_v4, 'a+' )
if user_input.args.ipv6 == 1:
    ipblocks_v6 = open( user_input.output_ip_list_v6, 'a+' )
    ipv6 = 1
else:
    ipBlocks_v6 = None
    ipv6 = 0

# Create global lists and variables because multiprocessing will not pickle the instance variables properly.

domains = domainBlocks.read( )
domains = domains.split( "\n" )
lists = DomainIpLists( user_input, ipBlocks_v4, ipBlocks_v6, domainBlocks )
ips_v4 = ipBlocks_v4.read( )
ips_v4 = ips_v4.split( "\n" )
if ipv6 == 1:
    ips_v6 = ipblocks_v6.read( )
    ips_v6 = ips_v6.split( "\n" )
else:
    ips_v6 = []
domaincount :int =  len( domains )
ipcount_v4 :int =  len( ips_v4 )
ipcount_v6 :int = len( ips_v6 )
total_ipcount: int = ipcount_v4 + ipcount_v6
try:

    # Get user confirmation to proceed if in interactive mode

    time.sleep( 2 )
    if user_input.args.interactive == 1:
        goahead :str = input( 'Proceed? (Y/N) ' )
        while True:
            if goahead == 'Y' or goahead == "y":
                break
            elif goahead == 'N' or goahead == 'n':
                raise( '\nUser aborted processing.' )
            else:
                goahead = input( '\nInvalid entry. Please select Y, N, y, or n.\n\nProceed? (Y/N)' )
    time.sleep( 2 )

    # Instantiate the class for the blocklists parse the input, and reate the blocklists in parallel
    print(user_input.items)
    time.sleep(90)

    mp.set_start_method( 'spawn', force = True )
    with mp.Pool( mp.cpu_count( ) ) as pool:
        pool.map( processDomains, user_input.items )
        pool.map( ipLookup, domains )

    time.sleep( 2 )

        # Optimize the output files for human readability and machine-efficiency.
        # This will delete the content of the "WIP" blocklist files and replace
        # them with sorted, condensed versions thereof.

    print( '\n\nOptimizing blocklists.' )
    optimizeDomains( )
    optimizeIps( )
    time.sleep( 2 )
    domainBlocks.close( )
    ipBlocks_v4.close( )
    if ipv6 == 1:
        ipBlocks_v6.close( )

# If the user selected to create the ipset blocklists, process and create them.

    if user_input.args.ipset == 'Y' or 'y' or 1:
        ipset = IpsetBLocklists( )
        ipset.processIpsets( )

    # Le fin.

    print( '\n\nProcessing complete.' )

# ...but I am le tired.

except Exception as err:
    print( "Caught an exception:" )
    traceback.print_exc( )



#if __name__ == "__main__":
#    main ( )