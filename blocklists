#!/bin/python
#################################################################################################################
#################################################################################################################
# blocklists 
#
# Copyright 2025, CK Cameron (chase@ckcameron.net), Shared under the Gnu General Public License, version 3.0 ONLY
# Written in Python 3.14, using libraries re, pathlib, socket, time, elevate, argparse and ipaddress
#
# This program will parse a list of files and directories, to scrape each line for ipaddresses, 
#     and domain names. Domain names will be looked up for associated IPs. IPs and domains will 
#     be written to their respective files, and finally optimized by sorting, removing duplicate 
#     entries, and condensing the list of IPs into as few IP ranges as possible. If selected, the script will also create an ipset blocklist and add rules to your iptables firewall (default rule to blocking).
#          Note: The script currently will pickup and use impossible IP addresses,
#          e.g. 333.333.333.333. I have not run into problems with this as yet for my purposes,
#          although I may change it at a later date.
#################################################################################################################

# Import libraries

import re
from pathlib import Path
from elevate import elevate
import ipaddress
import socket
import time
import os
import argparse



# Define a class for user input and parse it out by splitting the input list and sorting through it for directories and files.

class Input:
    
    def __init__( self ):

        # Parse arguments passed to the script and, if necessary, gather missing data.

        self.parser = argparse.ArgumentParser(
            prog='blocklists.py',
            description='''A python cli for creating blocklists / ipsets and adding the rules to your iptables firewall.''',
            epilog="Copyright 2025 CK Camerousage='%(prog)s [options]n (chase@ckcameron.net), Licensed under GPLv3, all rights reserved.",
            usage='%(prog)s [options]'
            )
        self.parser.add_argument('f', '--files', default='', help="input blocklist filename(s) or directories, comma-separated" )
        self.parser.add_argument('i', '--interactive', default='1', help="interactive mode will ask for values for needed variables and about including operations" )
        self.parser.add_argument('is', '--ipset', default='0', help="create ipset blocklist" )
        self.parser.add_argument('in', '--ipset_name', default='blocklists-set', help="ipset blocklist name or name prefix" )
        self.parser.add_argument('it', '--ipset_type', default='net:hash', help="ipset type, default=net:hash" )
        self.parser.add_argument('oi', '--output_ip_list', default='', help="output ip blocklist filename or directory" )
        self.parser.add_argument('od', '--output_domain_list', default='', help="output domain blocklist filename or directory" )
        self.parser.add_argument('ipt', '--iptables_rules', default='0', help="add iptables rules to firewall. The default blocks incoming and outgoing traffic across all connections to or from those ips." )
        self.parser.add_argument('ipto', '--iptables_options', default='-j DROP', help="iptables options to customize the rule, the ipset name(s) taken from the supplied argument. When using this options all flags beyond the ipset name for the rule need to be included. These include things like tables, direction, actions, ports." )
        self.args = self.parser.parse_args()

        # When in interactive mode, ather essentail inputs and determine if the user would like ipsets created, config files written, etc.

        if self.args.interactive == 1:
            self.args.files = input( "Please enter a comma-separated list of directories or files to be parsed:" )
            self.args.output_domain_list = Path( input( "Please enter the name of the output domain block file:" ) )
            self.args.output_ip_list = Path( input( "Please enter the name of the output ip block file:" ) )
            self.args.ipset = input("Do you want to create the ipset file int /etc/ipsets? (Y/N)")

            #Gain root privileges if we are doing operations that require it.
            if self.args.ipset == 'Y' or 'y':
                self.args.ipset_name = input("Please provide a name for the ipset(s) to be created: ")
                self.args.ipset_type = input("Please provide a type of ipset(s) to be created: ")
                self.args.iptables_rules = input("Shall the script create iptables rules for the ipset(s) created? (Y/N [default]) ")
                self.args.iptables_options = input("Enter iptables options to be appended after the ipset name in the rules, or hit [Enter] for the default incoming and outgoing block:")
                while os.geteuid() != 0:
                    print("\n[sudo] password for %u required to run this script with currently given options. \n\nPlease enter your sudo password:")
                    elevate()
        if self.args.iptables_options == '':
            self.args.iptables_options = '-j DROP'

        # If minimal arguments are not supplied and the script is not in interactive mode, explain what is missing and exit.

        if self.args.files == '':
            raise('\n\nRequired input files or directories not given. Exiting.')
            return 1
        if self.args.output_ip_list == '':
            raise("Output IP list filename not given. Exiting.")
        if self.args.output_domain_list == '':
            raise("Output domain list filename not given. Exiting.")

        # Parse user input for filenames and directories, adding any files to the list to parse.

        self.userInput = self.args.files.split(",")
        self.items = []
        for object in self.userInput:
            object = Path( object )
            for item in object.rglob( '*' ):
                if item.is_file() and item not in self.items:
                    self.items.append( item )
                    print( item, " added to the list for processing." )
                    time.sleep( 0.01 )

# Create a class for the processed ips and domains

class DomainIpLists:
    
    def __init__( self ):
        
        # Create necessary variables and empty lists
        self.uniqueips :int = 0
        self.domaincount :int = 0
        self.ipcount :int = 0
        self.ips = []
        self.domains = []
        self.filedata = []
        self.file :str = ""
        self.extracted = None
        self.line :str = ""
        self.cleanedLines = []

    def parseFile( self ):

        # Open each file in the file list for processing and parse it
        
        print( "\nProcessing", self.file )
        with open( self.file, 'r' ) as data:

            # Evaluate lines for the presence of erroneous characters and patterns, strip them,
            # and pull out only those that contain ip addresses

            self.filedata = []
            for line in data:
                line = line.strip()
                line = line.removeprefix( '.' )
                # Remove comments
                if re.search( '#', line ) is not None:
                    marker :str = '#'
                    line = line.split(marker, 1)[0]
                line = line.replace("http://", "")
                line = line.replace("|", "")
                self.filedata.append( line )
    
    def optimizeIps( self ):
        print( "\nNow optimizing IP blockfile and removing duplicates...." )
        
        # Sort IPs.

        self.ips = sorted( self.ips, key=ipaddress.ip_address )

        # Optimize the list of IPs for ipset by removing duplicates and compressing addressses into as many contiguous ranges as possible.
        # Then delete the contents of the IP block file to write the optimized contents to it.

        uniqueips = list( set( self.ips ) )
        print( "\nIP count after removing duplicates:", len( uniqueips ) )
        time.sleep( 2 )
        ipsoptimized = ipaddress.collapse_addresses( uniqueips )
        time.sleep( 2 )
        print( "\nEntry count after collapsing ip ranges:", len( ipsoptimized ) )
        self.ips = []
        for iprange in ipsoptimized:
            self.ips.append( iprange )
        ipBlocks.seek( 0 )
        ipBlocks.truncate()
        for entry in self.ips:
            ipBlocks.write( ( entry + '\n' ) )
        print( self.ipcount, "\nIPs including ", ( self.ipcount - len( self.ips ) ), "IP ranges added to the blockfile." )

    def processDomains( self ):
        
        # Take a line of input, remove any 0.0.0.0 entries, search for another existent IP Address in the line, 
        # and add it to the IP blockfile and the list of IPs. Stop processing the function by returning
        # True if an IP is found, written and appended to the IP list.

        self.line = self.line.replace( '0.0.0.0', '' )
        pattern = r'\b(?:\d{1,3}\.){3}\d{1,3}\b'
        match = re.search( pattern, self.line )
        if match:
            self.ips.append( match.group( ) )
            print('\n\n     Found IP, not a domain, so', match.group( ), 'added to IP blocklist.\n\n' )
            ipBlocks.write( match.group( ) )
            ipBlocks.write( '\n' )
            self.ipcount += 1
            return True
        
        else:
            
            # Now search the line for a string including any letter, a hyphen, or a digit, 
            # strip the leading "www.", add it to the domain blocklist, and the domain 
            # blockfile.

            pattern = r'^[a-zA-Z0-9\-\\.]+$'
            match = re.search( pattern, self.line )
            if match:
                    unstrippedwww = str( match.group( ) )

                    self.extracted = unstrippedwww.replace( 'www.', '' )
                    print( "Adding domain to block list:", self.extracted )
                    self.domains.append( self.extracted )
                    domainBlocks.write( ( self.extracted + '\n' ) )
                    self.domaincount += 1

    def ipLookup( self ):
        
        # Attempt to lookup the given domain name in each line and find associated IP address records, 
        # without failure if no result or an error is returned. Write associated IPs to the IP blocklist 
        # and blockfile. 

        try:
            hostinfo = socket.gethostbyname_ex( self.extracted )
            print ( "IP address(es):", hostinfo[2], "added to the ip block file." )
                
            [ self.ips.append( address ) for address in hostinfo[2] if hostinfo[2] is not None ]
            [ ipBlocks.write( ( address + '\n' ) ) for address in hostinfo[2] if hostinfo[2] is not None ]
            self.ipcount += len( hostinfo[2] )
        except Exception as e:
            print( e )

    def optimizeDomains( self ):
        
        # Optimize the list of domains by eliminating duplicates and sorting them alphabetically before 
        # deleting the contents of the blockfile and writing the optimized contents to it 

        print( '\n\nNow optimizing the domain block file by removing duplicate entries and ordering the entries alphabetically.' )
        lists.domains = list( set( lists.domains ) )
        lists.domains = sort( lists.domains )
        domainBlocks.seek( 0 )
        domainBlocks.truncate()
        for domain in lists.domains:
            domainBlocks.write( domain + "\n" )
        print( lists.domaincount, "domains added to the block file.\n" )


#Main portion of the script using the above classes

try:

    # Invoke the input class 

    user_input = Input()
    
    # Get user confirmation to proceed
    
    time.sleep( 2 )
    goahead :str = input( 'Proceed? (Y/N) ' )
    while True:
        if goahead == 'Y' or goahead == "y":
            break
        elif goahead == 'N' or goahead == 'n':
            raise( '\nUser aborted processing.' )
            break
        else:
            goahead = input( '\nInvalid entry. Please select Y, N, y, or n.\n\nProceed? (Y/N)' )
    time.sleep( 2 )
    
    # Instantiate the class for the blocklists and parsing functions

    lists = DomainIpLists()
    
    # Open the domain and ip block files and parse the the list of lines from input,
    # adding filedata to appropriate files
    
    with open( user_input.args.output_domain_list, 'a' ) as domainBlocks:
        with open( user_input.args.output_ip_list, 'a' ) as ipBlocks:
            for listfile in user_input.files:
                lists.file = listfile
                lists.parseFile()
                for line in lists.filedata:
                    lists.line = line
                    lists.processDomains()
                    lists.ipLookup()
            time.sleep( 2 )
            
            # Optimize the output files for human readability and machine-efficiency. 
            # This will delete the content of the "WIP" blocklist files and replace 
            # them with sorted, condensed versions thereof.

            print( '\n\nOptimizing blocklists.' )
            lists.optimizeDomains()
            lists.optimizeIps()
            time.sleep( 2 )
            
            # Le fin.

            print( '\n\nProcessing complete.' )
                                                             # ...but I am le tired.
except Exception as e:
    print( e )
