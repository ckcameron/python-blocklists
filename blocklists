#!/usr/bin/env python3
#################################################################################################################
#################################################################################################################
# blocklists
#
# Copyright 2025, CK Cameron (chase@ckcameron.net), Shared under the Gnu General Public License, version 3.0 ONLY.
# Written in Python 3.14, using libraries re, http.clioent, traceback, pathlib, socket, time, elevate,
# URLExtract, ssl, subprocess, cmd, argparsei, tempfile, multiprocessing, and ipaddress.
#
# This program will parse a list of files and directories, to scrape each line for ipaddresses,
#     and domain names. Domain names will be looked-up for associated IPs. IPs and domains will
#     be written to their respective files, and finally optimized by sorting, removing duplicate
#     entries, and condensing the list of IPs into as few IP ranges as possible. If selected, the
#     script will also create an ipset blocklist and add rules to your iptables firewall
#     (the default rule is drop).
#
# The script relies on the presence of iptables, iprange, and ipset in the current ${PATH}.
#
# All logging is written to blocklists.log in the current directory.
#
# This program is distributed WITHOUT ANY WARRANTY; this includes it being without the implied warrant of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#################################################################################################################

# Import libraries

import http.client
import itertools
import socket
import ssl
import subprocess
import sys
import tempfile
import multiprocessing as mp
import re
from multiprocessing.pool import Pool
from pathlib import Path
from elevate import elevate
import ipaddress
import time
import os
import argparse
import traceback
from urlextract import URLExtract
import logging
import string
from alive_progress import alive_bar

# Set-up logging.

logger = logging.getLogger( __name__ )
file_handler = logging.FileHandler( './blocklists.log' )
file_handler.setFormatter( logging.Formatter( '%(asctime)s::%(levelname)s::'
                                            '%(name)s::%(funcName)s::'
                                            '%(lineno)d::%(message)s' ) )
file_handler.setLevel( logging.DEBUG )
logger.addHandler( file_handler )
logger.info( "Beginning processing." )


####### Global Functions ##########

def eprint(*args, **kwargs):
    print( *args, file=sys.stderr, **kwargs )

# Class for inputfiles and associated data

class InputFile( ):

    def __init__( self, file ):
        self.file = file
        self.filename = file
        self.path = Path( file )
        self.domains = []
        self.ips_v4 = []
        self.ips_v6 = []
        self.domaincount = 0
        self.ip4count = 0
        self.ip6count = 0
        self.total_ipcount = 0
        self.filedata = ""
        with open( self.file, 'r+' ) as f:
            self.filedata = f.read( )
        self.domain_ips_v4 = []
        self.domain_ips_v6 = []
        self.domains_string = f"##{self.filename}\n"
        self.ips_v4_string = f"##{self.filename}\n"
        self.ips_v6_string = f"##{self.filename}\n"
        time.sleep(.25)
        #print( f"{self.file} added to the list for processing." )




# Create a class for the processed ip and domain lists

class DomainIpLists:
    def __init__( self, inputdict, **kwargs ):
        # Create necessary variables and empty lists
        self.ipBlocks_v4_file = kwargs[ 'ipBlocks_v4_file' ]
        self.ipBlocks_v6_file = kwargs[ 'ipBlocks_v6_file' ]
        self.domainBlocks_file = kwargs[ 'domainBlocks_file' ]
        self.domainBlocks = open( self.domainBlocks_file, 'a+' )
        self.ipBlocks_v4 = open( self.ipBlocks_v4_file, 'a+' )
        self.ipBlocks_v6 = open( self.ipBlocks_v6_file, 'a+' )



    @classmethod
    def optimizeIps( cls, ip4file, ip6file ):
        print( "\nNow optimizing IP blockfile and removing duplicates...." )
        ipBlocks_v4 = open( ip4file, 'a+' )
        ipBlocks_v6 = open( ip6file, 'a+' )
        # Sort IPs.
        ipBlocks_v4.seek( 0 )
        ipBlocks_v6.seek( 0 )
        ips_v4 = [line.strip() for line in ipBlocks_v4.readlines() if line.strip()]
        ips_v6 = [line.strip() for line in ipBlocks_v6.readlines() if line.strip()]
        ips_v4 = sorted( ips_v4, key=ipaddress.ip_address )
        ips_v6 = sorted( ips_v6, key=ipaddress.ip_address )

        # Optimize the list of IPs for ipset by removing duplicates and compressing addressses into as many contiguous ranges as possible.
        # Then delete the contents of the IP block file to write the optimized contents to it.

        ips_v4 = list( set( ips_v4 ) )
        ips_v6 = list( set( ips_v6 ) )
        logger.info( f"IPv4 count after removing duplicates: {len( ips_v4 )}" )
        logger.info( f"IPv6 count after removing duplicates: {len( ips_v6 )}" )
        time.sleep( 2 )
        ips_v4 = ipaddress.collapse_addresses( [ipaddress.ip_network(ip, strict=False) for ip in ips_v4] )
        ips_v6 = ipaddress.collapse_addresses( [ipaddress.ip_network(ip, strict=False) for ip in ips_v6] )
        time.sleep( 2 )
        ips_v4 = "\n".join( str(ip) for ip in ips_v4 )
        ips_v6 = "\n".join( str(ip) for ip in ips_v6 )
        ipBlocks_v4.seek( 0 )
        ipBlocks_v4.truncate( )
        ipBlocks_v4.write( ips_v4 )
        ipBlocks_v4.flush( )
        ipBlocks_v6.seek(0)
        ipBlocks_v6.truncate()
        ipBlocks_v6.write( ips_v6 )
        ipBlocks_v6.flush( )
        ipBlocks_v4.close( )
        ipBlocks_v6.close( )
        subprocess.run( ["iprange", "optimize", ip4file] )
        subprocess.run( ["iprange", "optimize", ip6file] )

    # Optimize the list of domains by eliminating duplicates and sorting them alphabetically before
    # deleting the contents of the blockfile and writing the optimized contents to it.

    @classmethod
    def optimizeDomains( cls, file ):
        domainBlocks_file = file
        print( '\n\nNow optimizing the domain block file by removing duplicate entries and ordering the entries alphabetically.' )
        domainBlocks = open( domainBlocks_file, 'a+' )
        domainBlocks.seek( 0 )
        domains = domainBlocks.readlines( )
        domains = set( domains )
        domains = sorted( domains )
        domaincount = len( domains )
        domainBlocks.seek( 0 )
        domainBlocks.truncate( )
        domains = "\n".join( domains )
        domainBlocks.write( domains )
        domainBlocks.flush( )
        domainBlocks.close( )
        logger.info( f"{domaincount} domains optimized in the block file.\n" )

    # Take a line of input, remove any 0.0.0.0 entries, search for another existent IP Address in the line,
    # and add it to the IP blockfile and the list of IPs. Stop processing the function by returning
    # True if an IP is found, written and appended to the IP list.

    @classmethod
    def processIPs( cls, inputfile ):
        file = inputfile
        logger.info( f"\nProcessing { file.filename } for IP addresses and extracting domains..." )
        match_v4 = re.compile(r"(?:(?:2(?:[0-4][0-9]|5[0-5])|[0-1]?[0-9]?[0-9])\.){3}(?:(?:2(?:[0-4][0-9]|5[0-5])|[0-1]?[0-9]?[0-9]))(?:\/(?:[12]?[0-9]|3[0-2]))?", re.IGNORECASE )

        match_v6 = re.compile(r"^((?:[0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}|(?:[0-9A-Fa-f]{1,4}:){1,7}:|:(?::[0-9A-Fa-f]{1,4}){1,7}|(?:[0-9A-Fa-f]{1,4}:){1,6}:[0-9A-Fa-f]{1,4}|(?:[0-9A-Fa-f]{1,4}:){1,5}(?::[0-9A-Fa-f]{1,4}){1,2}|(?:[0-9A-Fa-f]{1,4}:){1,4}(?::[0-9A-Fa-f]{1,4}){1,3}|(?:[0-9A-Fa-f]{1,4}:){1,3}(?::[0-9A-Fa-f]{1,4}){1,4}|(?:[0-9A-Fa-f]{1,4}:){1,2}(?::[0-9A-Fa-f]{1,4}){1,5}|[0-9A-Fa-f]{1,4}:(?:(?::[0-9A-Fa-f]{1,4}){1,6})|:(?:(?::[0-9A-Fa-f]{1,4}){1,6}))$", re.IGNORECASE )
        match_v6_cidr = re.compile(r"(?:(?:(?:[A-F0-9]{1,4}:){6}|(?=(?:[A-F0-9]{0,4}:){0,6}(?:[0-9]{1,3}\.){3}[0-9]{1,3}(?![:.\w]))(([0-9A-F]{1,4}:){0,5}|:)((:[0-9A-F]{1,4}){1,5}:|:)|::(?:[A-F0-9]{1,4}:){5})(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)|(?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}|(?=(?:[A-F0-9]{0,4}:){0,7}[A-F0-9]{0,4}(?![:.\w]))(([0-9A-F]{1,4}:){1,7}|:)((:[0-9A-F]{1,4}){1,7}|:)|(?:[A-F0-9]{1,4}:){7}:|:(:[A-F0-9]{1,4}){7})(?![:.\w])\/(?:12[0-8]|1[01][0-9]|[1-9]?[0-9])", re.IGNORECASE )
        t1 = match_v4.findall( file.filedata )
        t2 = match_v6.findall( file.filedata )
        t3 = match_v6_cidr.findall( file.filedata )
        combinedv6 = t2 + t3
        logger.info( f" RegEx Match: Completed line regular expression searches." )
        for address in t1:
            if address != " 0.0.0.0 ":
                file.ip4count += 1
                file.ips_v4.append( address )
                logger.info( f"IP4: Added ipsv4 to the file ip lists." )
        for address in combinedv6:
            file.ip6count += 1
            file.ips_v6.append( address )
            logger.info( f"\nIP6: Added ipsv6 to the file ip lists." )
        for ip in file.ips_v4:
            file.ips_v4_string += f'{ ip }\n'
        for ip in file.ips_v6:
            file.ips_v6_string += f'{ ip }\n'

        # Report file totals.

        logger.info( f"Raw IP Processing complete for file: {inputfile}" )

    @classmethod
    def processDomains( cls, inputfile ):
        file = inputfile
        logger.info( f"\nProcessing {file.filename} and extracting domains...")

        match_v4 = re.compile(r"(?:(?:2(?:[0-4][0-9]|5[0-5])|[0-1]?[0-9]?[0-9])\.){3}(?:(?:2(?:[0-4][0-9]|5[0-5])|[0-1]?[0-9]?[0-9]))(?:\/(?:[12]?[0-9]|3[0-2]))?", re.IGNORECASE )
        match_v6 = re.compile(r"^((?:[0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}|(?:[0-9A-Fa-f]{1,4}:){1,7}:|:(?::[0-9A-Fa-f]{1,4}){1,7}|(?:[0-9A-Fa-f]{1,4}:){1,6}:[0-9A-Fa-f]{1,4}|(?:[0-9A-Fa-f]{1,4}:){1,5}(?::[0-9A-Fa-f]{1,4}){1,2}|(?:[0-9A-Fa-f]{1,4}:){1,4}(?::[0-9A-Fa-f]{1,4}){1,3}|(?:[0-9A-Fa-f]{1,4}:){1,3}(?::[0-9A-Fa-f]{1,4}){1,4}|(?:[0-9A-Fa-f]{1,4}:){1,2}(?::[0-9A-Fa-f]{1,4}){1,5}|[0-9A-Fa-f]{1,4}:(?:(?::[0-9A-Fa-f]{1,4}){1,6})|:(?:(?::[0-9A-Fa-f]{1,4}){1,6}))$", re.IGNORECASE )
        match_v6_cidr = re.compile(r"(?:(?:(?:[A-F0-9]{1,4}:){6}|(?=(?:[A-F0-9]{0,4}:){0,6}(?:[0-9]{1,3}\.){3}[0-9]{1,3}(?![:.\w]))(([0-9A-F]{1,4}:){0,5}|:)((:[0-9A-F]{1,4}){1,5}:|:)|::(?:[A-F0-9]{1,4}:){5})(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)|(?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}|(?=(?:[A-F0-9]{0,4}:){0,7}[A-F0-9]{0,4}(?![:.\w]))(([0-9A-F]{1,4}:){1,7}|:)((:[0-9A-F]{1,4}){1,7}|:)|(?:[A-F0-9]{1,4}:){7}:|:(:[A-F0-9]{1,4}){7})(?![:.\w])\/(?:12[0-8]|1[01][0-9]|[1-9]?[0-9])", re.IGNORECASE )

        # Now search the text for urls, discard IP addresses, and add the sanitized group to the domain blocklist.
        extractor = URLExtract( allow_mixed_case_hostname = True, limit = 50000, cache_dns = True )
        try:
            extractor.update( )
        except Exception as err:
            print("Caught an exception:")
            traceback.print_exc()
            logger.info(traceback.print_exc())

        urls = extractor.find_urls( file.filedata, only_unique = True, check_dns = True  )
        logger.info( f"\nExtracted the following URLs form the text: {urls} .")
        for url in urls:
            url = url.replace("http://", "" )
            url = url.replace( "https://", "" )
            bar_search = re.compile( r"^||.*")
            bars = bar_search.findall(url)
            if bars:
                 url = url[2:]
            url = url.replace( "||", "" )
            url = url.replace( '\n', "" )
            url = url.strip( )
            url = url.strip( "\n" )
            url = url.strip( "||" )
            rem_char = "|"
            url = url.replace( rem_char, "" )
            if "localhost" in url:
                continue
            print(f"url before split: {url}")
            time.sleep(.3)
            spliturl = url.split( '/' )
            spliturl = spliturl[0]
            logger.info( f"\nspliturl {spliturl}")
            if "http" not in spliturl and "https" not in spliturl:
                if str(spliturl[0]) != "0.0.0.0":
                    res4 = match_v4.findall(spliturl)
                    res5 = match_v6.findall(spliturl)
                    res6 = match_v6_cidr.findall(spliturl)
                    if res4 or res5 or res6:
                        pass
                    elif spliturl == "http:":
                        pass
                    elif spliturl == "https:":
                        pass
                    else:
                        logger.info( f"\n\nDomain Add: Adding domain: {spliturl} to the domain blocklist.")
                        file.domains.append( spliturl )
                        file.domaincount += 1
                        file.domains_string += f'{spliturl}\n'
                        logger.info( f"\n\nGlobal Domains: Adding domain {spliturl} to the domain string globally." )

        print( f"Domains in file:  {domains}\n\nDomain count: {domaincount}")
        # Report file totals.
        global total_ipcount
        total_ipcount += file.ip4count + file.ip6count
        print( f"Parsing completed for file: {inputfile.filename} . " )
        logger.info( f"\n\nAll parsing completed for File : {inputfile} processed.\n\n\nThe following {inputfile.domaincount} domains were added to the blocklist:\n {inputfile.domains}\n\nThe following {inputfile.ip4count} IPv4 addresses were added to the blocklist: \n{inputfile.ips_v4}\n\nThe following {inputfile.ip6count} IPv6 addresses were added to the blocklist: \n{inputfile.ips_v6}\n\n...... {total_ipcount} IP addresses added to the blocklists thusfar." )


    # Attempt to lookup the given domain name in each line and find associated IP address records,
    # without failure if no result or an error is returned. Write associated IPs to the IP blocklist
    # and blockfile..

    @classmethod
    def ipLookup( cls, fileobj):
        try:
            file = fileobj
            for domain in file.domains:
                hostinfo = socket.gethostbyname_ex( domain )
                print( f"\nRetrieving IP address(es) for domain {domain}..." )
                [ ( print( f"\nIP address(es): {hostinfo[2]} added to the ip block file." ) ) for address in hostinfo[2] if hostinfo[2] is not None and address not in file.ips_v4 ]
                for address in hostinfo[2]:
                    if hostinfo[2] is not None:
                        if address not in file.ips_v4:
                            file.ip4count += 1
                            logger.info( f"Adding IPv4 address {address} to the blocklist for domain {domain}" )
                            file.ips_v4.append( address )
                            file.ips_v4_string += f"{address}\n"
                hostaddrinfo = socket.getaddrinfo( domain, None,  socket.AF_INET6 )
                for address in hostaddrinfo[0]:
                    if hostaddrinfo[0] is not None:
                        if address not in file.ips_v6:
                            file.ip6count += 1
                            print( f"Adding IPv6 address {address} to the blocklist for domain {domain}" )
                            file.ips_v6.append( address )
                            file.ips_v6_string += f"{address}\n"

        # Print any exception caught in the process

        except Exception as err:
            print( "Caught an exception:" )
            traceback.print_exc( )
            logger.info( traceback.print_exc( ) )
            print( "Program continues to run after the traceback." )



# Class for a subnet's network address and mask to be cached

class Network:

    def __init__( self, subnet ):
        network = ipaddress.ip_network( subnet )
        self.network_ipspace = int( network.network_address )
        self.subnet_mask = int( network.netmask )

# Creates ipset blocklist from optimized ip blockfiles. IPv4 and IPv6 Supported.

class IpsetBlocklist:
    def __init__( self, inputlists, inputfiledict, **kwargs ):
        self.domainBlocks_file = kwargs['domainBlocks_file']
        self.ipBlocks_v4_file = kwargs['ipBlocks_v4_file']
        self.ipBlocks_v6_file = kwargs['ipBlocks_v6_file']
        self.ipset_location = kwargs['ipset_location']
        self.ipset4_name = kwargs['ipset4_name']
        self.ipset6_name = kwargs['ipset6_name']
        self.lists = inputlists
        self.inputfileobjects = inputfiledict
        self.ipBlocks_v4 = open( self.ipBlocks_v4_file, 'a+' )
        self.ipBlocks_v6 = open( self.ipBlocks_v6_file, 'a+' )
        self.domainBlocks = open( self.domainBlocks_file, 'a+' )
        self.ipset4_file = str( f"{self.ipset_location}/{self.ipset4_name}" )
        self.ipset6_file = str( f"{self.ipset_location}/{self.ipset6_name}" )


        self.blocklist_list = []
        self.ipset_v4 = []
        self.ipset_v6 = []
        self.ipset_ipcount_v4 = 0
        self.ipset_ipcount_v6 = 0

        self.temporary_ipset_name_v4 = "ipset-blocklist"
        self.permanent_ipset_basename_v4 = self.ipset4_name
        self.temporary_ipset_name_v6 = "ipset-blocklist6"
        self.permanent_ipset_basename_v6 = self.ipset6_name

        # Determine how many entries there are to be in the given ipset(s) and divide the workload based on a counter when
        # writing-out the sets

        self.ipBlocks_v4.seek( 0 )
        self.bulk_ips4 = self.ipBlocks_v4.readlines( )
        self.ipv4total = len( self.bulk_ips4 )
        self.element_groups_v4 = ( self.ipv4total // 65535 ) + 1
        self.ipset_groups4 = []
        group_counter = 1
        for group in range( 1, ( self.element_groups_v4 ) ):
            group_name = "{}-{}".format( self.ipset4_name, group )
            group_file = f"/tmp/{group_name}"
            self.ipset_groups4.append( group_file )
            with open(group_file, 'a+' ) as group_list:
                if group == 1:
                    rangestart = 0
                else:
                    rangestart = (group -1) * 65535
                for i in range(rangestart, ( (group * 65535) - 1 ) ):
                    group_list.write( f"{self.bulk_ips4[i]}\n" )

        self.ipBlocks_v6.seek( 0 )
        bulk_ips6 = self.ipBlocks_v6.readlines( )
        self.ipv6total = len( bulk_ips6 )
        self.element_groups_v6 = ( self.ipv6total // 65535 ) + 1
        self.ipset_groups6 = []
        group_counter = 1
        for group in range(1, ( self.element_groups_v6 ) ):
            group_name = "{}-{}".format( self.ipset6_name, group )
            group_file = f"/tmp/{group_name}"
            self.ipset_groups6.append( group_file )
            with open( group_file, 'a+' ) as group_list:
                if group == 1:
                    rangestart = 0
                else:
                    rangestart = ( group -1 ) * 65535
                for i in range( rangestart, ( ( group * 65535 ) - 1 ) ):
                    group_list.write( f"{bulk_ips6[i]}\n" )

    # Write file headers by ipset restore

    @classmethod
    def writeHeader( cls, temporary_ipset_name_v4, header ):
        temporary_ipset_name_v4.write( bytearray( "{}\n".format( header ), 'utf-8' ) )
        temporary_ipset_name_v4.flush( )

    #Generate ipsets

    def createIpsets( self, name, family, comment=True, maxelem=65535 ):

        # Determine if the ipset we are workign with is IPv4 or IPv6, read the input data, find the network
        # range, and create the appropriately named ipset.

        if family == "inet":
            for group in self.ipset_groups4:
                with open( group, 'r+' ) as ipset_group:
                    ipset_lines = ipset_group.readlines( )
        else:
            for group in self.ipset_groups6:
                with open(group, 'r+') as ipset_group:
                    ipset_lines = ipset_group.readlines()
        first_line = ipset_lines[0]
        last_line = ipset_lines[-1]
        if "/" in first_line:
            first_address = first_line.split( "/" )[0]
        else:
            first_address = first_line
        if "/" in last_line:
            last_network = ipaddress.ip_network( last_line )
            last_address = last_network[-1]
        else:
            last_address = last_line
        self.range = "{}-{}".format( first_address, last_address )
        if comment:
            format_string = "create {} bitmap:ip range {} {} maxelem {} comment"
        else:
            format_string = "create {} bitmap:ip range {} {} maxelem {}"
        return format_string.format(name, self.range, family, maxelem )

    # ipset restore the filename
    @classmethod
    def restoreIpsetFile( cls, filename ):
        cmd = "ipset -exist -f {} restore".format( filename ).split( " " )

        process = subprocess.Popen( cmd )
        process.wait( )

        if process.returncode != 0:
            print( "Restoring the ipset {} failed with error {}".format(filename, process.returncode ) )
            return False
        return True

    # Generate names and ipsets for the different address families

    def nameFormat( self, name ):
        ipset4_names = []
        ip6set_names = []
        name_ordinal = 1
        for i in range( 1, ( self.element_groups_v4 ) ):
            ip4set_name = "{}-{}".format( self.ipset4_name, i )
            ipset4_names.append( ip4set_name )
        name_ordinal = 1
        for i in range(1, ( self.element_groups_v6 ) ):
            ip6set_name = "{}-{}".format( self.ipset6_name, i )
            ip6set_names.append( ip6set_name )
        return ipset4_names, ip6set_names

    # Destroy existing ipset

    @classmethod
    def ipsetDestroy( cls, set_1 ):
        cmd = "ipset destroy {}".format( set_1 ).split( " " )

        process = subprocess.Popen( cmd )
        process.wait( )
        if process.returncode != 0:
            print( "Deleting the ipset {} returned error {}".format(set_1, process.returncode ) )
            return False
        return True

    # Swap the two given ipsets.

    @classmethod
    def swapIPsets( cls, set_1, set_2 ):
        cmd = "ipset swap {} {}".format(set_1, set_2 ).split( " " )

        process = subprocess.Popen( cmd )
        process.wait( )
        if process.returncode != 0:
            eprint( "Swapping the ipsets {} and {} returned error {}".format(
                set_1, set_2, process.returncode ) )
            return False
        return True

    # Download blocklists - not yet impllemented -coming soon
    #    def get_list( self ):
    #96332e
    #    ctx = ssl.create_default_context( )
    #    ctx.options |= ssl.OP_NO_TLSv1
    #    ctx.options |= ssl.OP_NO_TLSv1_1
    #    ctx.options |= ssl.OP_NO_COMPRESSION

    #    # https connection for download

    #    connection = http.client.HTTPSConnection(
    #        self.blocklists_fqdn,
    #        context=ctx, timeout=5 )
    #    try:
    #        connection.connect( )
    #    except:
    #        eprint( "Connection error." )
    #
    #    try:
    #        connection.request( "GET", self.blocklists_file_v4 )
    #    except socket.error as e:
    #        eprint( "Socket error: {}".format( e ) )
    #        return False
    #    except socket.timeout as timeout:
    #        eprint( "Socket error: Connection timed out." )
    #        return False

    #   response = connection.getresponse( )

    #    if response.status != 200:
    #        eprint( "Server responded with statuscode {}. Aborting".format( response.statuscode ) )
    #        return False

    #    body = response.read( )
    #    if not body:
    #        eprint( "Server didn't send us any data." )
    #        return False

    #    self.blocklist_list = body.decode( ).split( "\n" )
    #   return True

    # Filter ipblocklists for bogon and private addresses and process the ipset files

    def processIpsets( self ):

        # set up IPv4 and IPv6 temporary files

        private_v4 = []
        for net in [
                "0.0.0.0/8", "10.0.0.0/8", "100.64.0.0/10", "172.16.0.0/12",
                "192.168.0.0/16", "169.254.0.0/16", "255.0.0.0/8",
                "224.0.0.0/4"
            ]:
            private_v4.append( Network( net ) )

        private_v6 = []
        for net in [
                "ff00::/8",
                "fe80::/10",
                "fd00::/8"
            ]:
            private_v6.append( Network ( net ) )

        temporary_file_v4 = tempfile.NamedTemporaryFile( )
        temporary_file_v6 = tempfile.NamedTemporaryFile( )

        add_template = "add {} {}\n"

        temporary_ipset_name_v4, temporary_ipset_name_v6 = self.nameFormat(
            self.temporary_ipset_name_v4 )

        permanent_ipset_basename_v4, permanent_ipset_basename_v6 = self.nameFormat(
            self.permanent_ipset_basename_v4 )

        self.writeHeader( temporary_file_v4.file, self.createIpsets( temporary_ipset_name_v4, family = "inet",  ) )

        self.writeHeader( temporary_file_v6.file, self.createIpsets( temporary_ipset_name_v6, family = "inet6", ) )

        # Write the formatted blockset.

        for address in itertools.chain(self.lists.ips_v4, self.lists.ips_v6 ):

            # Check if it's IPv4.

            if address.find( "." ) != -1:

                # Check for private subnet.

                is_private = False
                for inv in private_v4:
                    if ( int( ipaddress.ip_address( address ) ) & inv.subnet_mask ) == inv.network_ipspace:
                        is_private = True
                        break
                if is_private:
                    continue
                temporary_file_v4.file.write( bytearray(
                    add_template.format(temporary_ipset_name_v4, address ), 'utf-8' ) )
                self.ipset_ipcount_v4 += 1

            # else IPv6.

            else:

                # Check for private subnet.

                is_private = False
                for inv in private_v6:
                    if ( int( ipaddress.ip_address( address ) ) & inv.subnet_mask ) == inv.network_ipspace:
                        is_private = True
                        break
                if is_private:
                    continue
                temporary_file_v6.file.write(bytearray(
                    add_template.format(temporary_ipset_name_v6, address ), 'utf-8' ) )
                self.ipset_ipcount_v6 += 1

        # Flush the data to the tempfiles.

        temporary_file_v4.file.flush( )
        temporary_file_v6.file.flush( )

        # IPv4: place new ips in new set.

        self.restoreIpsetFile( temporary_file_v4.name )

        # Swap the temporary for the permanent set.

        self.swapIPsets( permanent_ipset_basename_v4, temporary_ipset_name_v4 )

        # Wipe the old ipset

        self.ipsetDestroy( temporary_ipset_name_v4 )

        # IPv6: place new ips in new set.

        self.restoreIpsetFile( temporary_file_v6.name )

        # Swap the temporary for the permanent set.

        self.swapIPsets( permanent_ipset_basename_v6, temporary_ipset_name_v6 )

        # Wipe the old set.

        self.ipsetDestroy( temporary_ipset_name_v6 )

        # Print results.

        print( "{} IPs added to the ipsets".format( self.ipset_ipcount_v4 + self.ipset_ipcount_v6 ) )

#Global Variables

inputfileobjects = {}
domains = []
domain_ip4_string = ""
domain_ip6_string = ""
ips_v4_string = ""
ips_v6_string = ""
domains_string = ""
ips_v4 = []
ips_v6 = []
domaincount = 0
ipv4_count = 0
total_ipcount = 0
ipv6_count = 0


# Global functions

# Create inputfile objects

def createInputObjects( items ):
    logger.info( "\n\nCreating input file objects..." )
    print( "\n\nCreating input file objects...\n" )
    with alive_bar( len( items ), title = 'Processing', length = 100, bar = 'fish', spinner = 'fishes' ) as bar:
        count = 0
        global inputfileobjects
        for item in items:
            bar.text( f"Processing item: {item}..." )
            inputfilename = f"input{
            count}"
            inputfileobjects[inputfilename] = InputFile(item)
            count += 1
            time.sleep( .2 )
            bar( )

###### Main portion of the script using the above classes ######


def main( ):

    print( "\n\nProcessing given input to create or update blocklists!" )
    time.sleep(1.5)
    print( "       \n\n\n...if problems are encountered, check the current directory for blocklists.log! " )

    try:

        parser = argparse.ArgumentParser(
            prog='blocklists.py',
            description='''A python cli for creating blocklists / ipsets and adding the rules to your iptables firewall.''',
            epilog="Copyright 2025 CK Cameron (chase@ckcameron.net), Licensed under GPLv3, all rights reserved.",
            usage='%(prog)s [options]'
        )
        parser.add_argument('-f', '--files', default='',
                                 help="input blocklist filename(s) or directories, comma-separated" )
        parser.add_argument('-6', '--ipv6', default='0', help="optional IPv6 processing (Default = No)" )
        parser.add_argument('-i', '--interactive', default='0',
                                 help="interactive mode will ask for values for needed variables and about including operations" )
        parser.add_argument('-is', '--ipset', default='0', help="create ipset blocklists" )
        parser.add_argument('-in4', '--ipset4_name', default='blocklists-set',
                                 help="ipset IPv4 blocklist name or name prefix" )
        parser.add_argument('-in6', '--ipset6_name', default='blocklists-set',
                                 help="ipset IPv6 blocklist name or name prefix" )
        parser.add_argument('-il', '--ipset_location', default='/etc/ipset',
                                 help="ipset config file location (Default: /etc/ipset)" )
        parser.add_argument('-oi4', '--output_ip_list_v4', default='',
                                 help="output IPv4 blocklist filename or directory" )
        parser.add_argument('-oi6', '--output_ip_list_v6', default='',
                                 help="output IPv6 blocklist filename or directory" )
        parser.add_argument('-od', '--output_domain_list', default='',
                                 help="output domain blocklist filename or directory" )
        parser.add_argument('-ipt', '--iptables_rules', default='0',
                                 help="add iptables rules to firewall. The default blocks incoming and outgoing traffic across all connections to or from those ips." )
        parser.add_argument('-ipto', '--iptables_options', default='-j DROP',
                                 help="iptables options to customize the rule, the ipset name(s) taken from the supplied argument. When using this options all flags beyond the ipset name for the rule need to be included. These include things like tables, direction, actions, ports." )
        parser.add_argument('-ad', '--allowed_domains', default='',
                            help="A file containing allowed domains that shall not be blocked, one per line." )
        parser.add_argument('-ai', '--allowed_ips', default='',
                            help="a list containing ips or subnets that shall not be blocked, one per line. These include private networks by default.")
        args = parser.parse_args( )

        # When in interactive mode, gather essential inputs and determine if the user would like ipsets created, config files written, etc.

        if args.interactive == '1':
            args.files = input( "Please enter a comma-separated list of directories or files to be parsed: " )
            args.output_domain_list = input( "Please enter the name of the output domain block file: " )
            args.output_ip_list_v4 = input( "Please enter the name of the output IPv4 block file: " )
            args.output_ip_list_v6 = input( "Please enter the name of the output IPv6 block file: " )
            args.ipset = input( "Do you want to create the ipset file int /etc/ipsets? (Y/N)" )

            # Gain root privileges if we are doing operations that require it.

            if args.ipset in ( 'Y', 'y', '1' ):
                args.ipset4_name = input(
                    "Please provide a name for the ipset(s) to be created (Default blocklists-ipset_v4-{number}): " )
                args.ipset6_name = input(
                    "Please provide a name for the ipset(s) to be created (Default blocklists-ipset_v6-{number}): " )
                args.ipset_location = input(
                    "Please provide a folder where the output ipset files should be placed (Default /etc/ipset.d): " )
                args.iptables_rules = input(
                    "Shall the script create iptables rules for the ipset(s) created? (Y/N [default]) " )
                args.iptables_options = input(
                    "Enter iptables options to be appended after the ipset name in the rules, or hit [Enter] for the default incoming and outgoing block: " )
                while os.geteuid() != 0:
                    print(
                        "\n[sudo] password for %u required to run this script with currently given options. \n\nPlease enter your sudo password:" )
                    elevate( )
        if args.iptables_options == '':
            args.iptables_options = '-j DROP'
        args.ipBlocks_v4_file = args.output_ip_list_v4
        args.ipBlocks_v6_file = args.output_ip_list_v6
        args.domainBlocks_file = args.output_domain_list


        # If minimal arguments are not supplied and the script is not in interactive mode, explain what is missing and exit.

        if args.files == '':
            raise SystemExit( '\n\nRequired input files or directories not given. Exiting.' )
        if args.output_ip_list_v6 == '' and args.ipv6 in ( '1', 'Y', 'y' ):
            raise SystemExit( "Output IPv6 list filename not given. Exiting." )
        else:
            if args.ipv6 in ( '1', 'Y', 'y' ):
                output_ip_list_v6 = Path( args.output_ip_list_v6 )
            else:
                pass
        if args.output_ip_list_v4 == '':
            raise SystemExit( "Output IPv4 list filename not given. Exiting." )
        else:
            output_ip_list_v4 = Path( args.output_ip_list_v4 )
        if args.output_domain_list == '':
            raise SystemExit( "Output domain list filename not given. Exiting." )
        else:
            output_domain_list = Path( args.output_domain_list )

        # Parse user input for filenames and directories, adding any files to the list to parse.

        userInput = args.files.split( "," )
        items = []
        for thing in userInput:
            for item in Path( thing ).rglob( '*' ):
                if item.is_file( ):
                    items.append( item )
                    logger.info( f"Adding {item} to the list of files to parse." )
        count = 0
        createInputObjects( items )
        lists = DomainIpLists( inputfileobjects, domainBlocks_file = args.output_domain_list, ipBlocks_v4_file = args.output_ip_list_v4, ipBlocks_v6_file = args.output_ip_list_v6 )
        ipsets = IpsetBlocklist( lists, inputfileobjects, domainBlocks_file = args.output_domain_list, ipBlocks_v4_file = args.output_ip_list_v4, ipBlocks_v6_file = args.output_ip_list_v6, ipset4_name = args.ipset4_name, ipset6_name = args.ipset6_name, ipset_location = args.ipset_location )


        # Get user confirmation to proceed if in interactive mode

        time.sleep( 2 )
        if args.interactive == '1':
            logger.info( "Interactive mode selected by user." )
            goahead :str = input( 'Proceed? (Y/N) ' )
            while True:
                if goahead == 'Y' or goahead == "y":
                    logger.info( "User has accepted the script's options and the script continues." )
                    break
                elif goahead == 'N' or goahead == 'n':
                    logger.info( "User has declined the script's options and the script exits." )
                    raise SystemExit( '\nUser aborted processing.' )
                else:
                    goahead = input( '\nInvalid entry. Please select Y, N, y, or n.\n\nProceed? (Y/N)' )
        time.sleep( 2 )


        # Parse the input, and create the blocklists in per-input-file parallel operations.
        print( "\n\nBeginning to process files. This may take a while...\n\n" )
        logger.info("\n\nBeginning to process files. This may take a while...\n\n" )
        logger.info( "Starting IP processing..." )
        mp.set_start_method( 'spawn', force = True )
        for o in inputfileobjects.values( ):
            print( o.filedata )
        print( inputfileobjects.values( ) )
        time.sleep( 30 )
        with alive_bar( len( items ), title = 'Finding IPs...', length = 100, bar = 'fish', spinner = 'fishes' ) as bar, mp.Pool( processes = mp.cpu_count( ) ) as pool:
            for _ in pool.map( lists.processIPs, inputfileobjects.values( ) ):
                bar.text( f"Processing file..." )
                bar( )
        with alive_bar(len( items ), title='Finding Domains...', length=100, bar='fish', spinner='fishes' ) as bar, mp.Pool( processes=mp.cpu_count( ) ) as pool:
            for _ in pool.map(lists.processDomains, inputfileobjects.values( ) ):
                bar.text( f"Processing file..." )
                bar( )
        with alive_bar(len( items ), title='Finding IPs by domain...', length=100, bar='fish', spinner='fishes' ) as bar, mp.Pool( processes=mp.cpu_count( ) ) as pool:
            for _ in pool.map(lists.ipLookup, inputfileobjects.values( ) ):
                bar.text( f"Processing domain list... " )
                bar( )
            logger.info( "IP lookup complete.\n\nNow beginning to write ipsets.\n\n" )
        with open( args.output_domain_list, 'a+' ) as domainBlocks:
            with open( args.output_ip_list_v4, 'a+') as ipBlocks_v4:
                with open( args.output_ip_list_v6, 'a+' ) as ipBlocks_v6:
                    domainBlocks.seek( 0 )
                    domaindata = domainBlocks.read( )
                    domaindata ="".join(domaindata)
                    domaindata = domaindata.split( "\n" )
                    global domains
                    domains = domaindata
                    global domaincount
                    domaincount += len( domaindata )
                    for o in inputfileobjects.values( ):

                        ipBlocks_v4.write( o.ips_v4_string )
                        ipBlocks_v6.write( o.ips_v6_string )
                        domainBlocks.write( o.domains_string )
                        domainBlocks.flush( )
                        ipBlocks_v4.flush( )
                        ipBlocks_v6.flush( )
        time.sleep( 2 )

        # Optimize the output files for human readability and machine-efficiency.
        # This will delete the content of the "WIP" blocklist files and replace
        # them with sorted, condensed versions thereof.

        print( '\n\nOptimizing blocklists...' )
        logger.info( "Optimizing blocklists, starting with the domain blocklists..." )
        lists.optimizeDomains( args.output_domain_list )
        logger.info( "Now optimizing the iplists and condensing the networks into as few entries as possible..." )
        lists.optimizeIps( args.output_ip_list_v4, args.output_ip_list_v6 )
        logger.info("Optimizations complete." )
        time.sleep( 2 )

        # If the user selected to create the ipset blocklists, process and create them.


        if args.ipset in ( 'Y', 'y', '1' ):
            logger.info( "Creating ipsets..." )
            print( "\n\nNow processing IPsets. Please standby. This should only take a second or two...\n\n            ...\n                                                   ...\n\n                                                   ..." )
            ipsets.processIpsets( )
            time.sleep( 2 )
            print( "\n\n\nProcessing Ipsets completed." )
        # Le fin.

        print( '\n\nProcessing complete.' )
        logger.info( "Processing complete." )
    # ...but I am le tired.

    except Exception as err:
        print( "Caught an exception:" )
        traceback.print_exc( )
        logger.info( traceback.print_exc( ) )

# Execution control section

if __name__ == "__main__":

    # Run the script.

    main( )
